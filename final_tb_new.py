# -*- coding: utf-8 -*-
"""Final_TB_NEW.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1zy5OiPwWdy3blkVRREpFol7JHzc4zQuv
"""

# Mount the drive
from google.colab import drive
drive.mount('/content/drive')

!kaggle datasets download -d tawsifurrahman/tuberculosis-tb-chest-xray-dataset

!unzip tuberculosis-tb-chest-xray-dataset.zip

# Commented out IPython magic to ensure Python compatibility.
# # Install TensorFlow and Keras
# %%capture
# !pip install tensorflow
# !pip install keras
# !pip install --upgrade tensorflow

# Importing necessary libraries
import numpy as np
import pandas as pd
import os
import cv2
from pathlib import Path
import seaborn as sns
import matplotlib.pyplot as plt
from skimage.io import imread
from sklearn.model_selection import train_test_split
from sklearn.metrics import confusion_matrix, accuracy_score, classification_report
import tensorflow as tf
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import Conv2D, MaxPooling2D, Flatten, Dense, Dropout
from tensorflow.keras.preprocessing.image import ImageDataGenerator
from tensorflow.keras.callbacks import EarlyStopping

# Set random seed for reproducibility
np.random.seed(42)
tf.random.set_seed(42)

# Directories for the normal and tuberculosis images
no_tb_data = "/content/TB_Chest_Radiography_Database/Normal"
tb_data = "/content/TB_Chest_Radiography_Database/Tuberculosis"

images = []
labels = []
imagesize = 180

# Load normal images and append label 0
for img in os.listdir(no_tb_data):
    img_path = os.path.join(no_tb_data, img)
    img_array = cv2.imread(img_path)
    img_resized = cv2.resize(img_array, (imagesize, imagesize))
    images.append(img_resized)
    labels.append(0)

# Load tuberculosis images and append label 1
for img in os.listdir(tb_data):
    img_path = os.path.join(tb_data, img)
    img_array = cv2.imread(img_path)
    img_resized = cv2.resize(img_array, (imagesize, imagesize))
    images.append(img_resized)
    labels.append(1)

# Convert the list to numpy arrays and normalize the image pixel values
X = np.array(images) / 255.0  # Normalizing the pixel values
y = np.array(labels)

# Splitting data into training and test sets
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

# Reshape the data (in case the color channels are not 3)
X_train = X_train.reshape(-1, imagesize, imagesize, 3)
X_test = X_test.reshape(-1, imagesize, imagesize, 3)

print(f"Training data shape: {X_train.shape}")
print(f"Testing data shape: {X_test.shape}")

# Building the CNN model
model = Sequential()

# Convolutional layers
model.add(Conv2D(32, (3, 3), activation='relu', input_shape=(imagesize, imagesize, 3)))
model.add(MaxPooling2D(pool_size=(2, 2)))

model.add(Conv2D(64, (3, 3), activation='relu'))
model.add(MaxPooling2D(pool_size=(2, 2)))

model.add(Conv2D(128, (3, 3), activation='relu'))
model.add(MaxPooling2D(pool_size=(2, 2)))

# Flattening the layers and adding fully connected layers
model.add(Flatten())
model.add(Dense(128, activation='relu'))
model.add(Dropout(0.5))
model.add(Dense(64, activation='relu'))
model.add(Dense(1, activation='sigmoid'))  # Binary classification (normal or TB)

# Compile the model
model.compile(optimizer='adam', loss='binary_crossentropy', metrics=['accuracy'])

# Model summary
model.summary()

# Early stopping to prevent overfitting
early_stopping = EarlyStopping(monitor='val_loss', patience=5, restore_best_weights=True)

# Training the model
history = model.fit(X_train, y_train, validation_split=0.2, epochs=20, batch_size=32, callbacks=[early_stopping])

# Plotting training and validation loss
plt.figure(figsize=(12, 6))

plt.subplot(1, 2, 1)
plt.plot(history.history['loss'], label='Training Loss')
plt.plot(history.history['val_loss'], label='Validation Loss')
plt.title('Training and Validation Loss')
plt.xlabel('Epochs')
plt.ylabel('Loss')
plt.legend()

# Plotting training and validation accuracy
plt.subplot(1, 2, 2)
plt.plot(history.history['accuracy'], label='Training Accuracy')
plt.plot(history.history['val_accuracy'], label='Validation Accuracy')
plt.title('Training and Validation Accuracy')
plt.xlabel('Epochs')
plt.ylabel('Accuracy')
plt.legend()

plt.show()

# Evaluate the model on test data
test_loss, test_accuracy = model.evaluate(X_test, y_test)
print(f"Test Loss: {test_loss}")
print(f"Test Accuracy: {test_accuracy}")

# Predicting on the test data
y_pred = (model.predict(X_test) > 0.5).astype("int32")

# Confusion matrix
conf_matrix = confusion_matrix(y_test, y_pred)
print("Confusion Matrix:\n", conf_matrix)

# Heatmap for confusion matrix
sns.heatmap(conf_matrix, annot=True, fmt="d", cmap="Blues")
plt.title("Confusion Matrix")
plt.xlabel("Predicted Labels")
plt.ylabel("True Labels")
plt.show()

# Classification report
print("Classification Report:\n", classification_report(y_test, y_pred))

# Save the trained model in Keras HDF5 format
model.save('/content/drive/MyDrive/TB_CNN_Model.keras')

# Function to preprocess and predict a single image
def predict_tuberculosis(image_path, model):
    # Load the image
    img = cv2.imread(image_path)

    # Resize the image to match the input size of the model (180x180 in this case)
    img_resized = cv2.resize(img, (imagesize, imagesize))

    # Normalize the image (as we did for training data)
    img_normalized = img_resized / 255.0

    # Reshape the image to add batch dimension (1, 180, 180, 3)
    img_reshaped = np.reshape(img_normalized, (1, imagesize, imagesize, 3))

    # Predict using the model (returns a probability between 0 and 1)
    prediction = model.predict(img_reshaped)

    # If prediction is greater than 0.5, it's Tuberculosis, otherwise it's Normal
    if prediction > 0.5:
        print(f"The model predicts: Tuberculosis with confidence {prediction[0][0] * 100:.2f}%")
    else:
        print(f"The model predicts: Normal with confidence {(1 - prediction[0][0]) * 100:.2f}%")

# Example usage
image_path = "/content/TB_Chest_Radiography_Database/Tuberculosis/Tuberculosis-102.png"  # Path to the new image
predict_tuberculosis(image_path, model)

# Function to preprocess and predict a single image
def predict_tuberculosis(image_path, model):
    # Load the image
    img = cv2.imread(image_path)

    # Resize the image to match the input size of the model (180x180 in this case)
    img_resized = cv2.resize(img, (imagesize, imagesize))

    # Normalize the image (as we did for training data)
    img_normalized = img_resized / 255.0

    # Reshape the image to add batch dimension (1, 180, 180, 3)
    img_reshaped = np.reshape(img_normalized, (1, imagesize, imagesize, 3))

    # Predict using the model (returns a probability between 0 and 1)
    prediction = model.predict(img_reshaped)

    # If prediction is greater than 0.5, it's Tuberculosis, otherwise it's Normal
    if prediction > 0.5:
        print(f"The model predicts: Tuberculosis with confidence {prediction[0][0] * 100:.2f}%")
    else:
        print(f"The model predicts: Normal with confidence {(1 - prediction[0][0]) * 100:.2f}%")

# Example usage
image_path = "/content/TB_Chest_Radiography_Database/Normal/Normal-1.png"  # Path to the new image
predict_tuberculosis(image_path, model)

# Function to preprocess and predict a single image
def predict_tuberculosis(image_path, model):
    # Load the image
    img = cv2.imread(image_path)

    # Resize the image to match the input size of the model (180x180 in this case)
    img_resized = cv2.resize(img, (imagesize, imagesize))

    # Normalize the image (as we did for training data)
    img_normalized = img_resized / 255.0

    # Reshape the image to add batch dimension (1, 180, 180, 3)
    img_reshaped = np.reshape(img_normalized, (1, imagesize, imagesize, 3))

    # Predict using the model (returns a probability between 0 and 1)
    prediction = model.predict(img_reshaped)

    # If prediction is greater than 0.5, it's Tuberculosis, otherwise it's Normal
    if prediction > 0.5:
        print(f"The model predicts: Tuberculosis with confidence {prediction[0][0] * 100:.2f}%")
    else:
        print(f"The model predicts: Normal with confidence {(1 - prediction[0][0]) * 100:.2f}%")

# Example usage
image_path = "/content/TB_Chest_Radiography_Database/Normal/Normal-1008.png"  # Path to the new image
predict_tuberculosis(image_path, model)